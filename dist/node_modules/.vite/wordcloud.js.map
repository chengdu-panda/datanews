{
  "version": 3,
  "sources": ["../wordcloud/src/wordcloud2.js", "dep:wordcloud"],
  "sourcesContent": ["/*!\n * wordcloud2.js\n * http://timdream.org/wordcloud2.js/\n *\n * Copyright 2011 - 2019 Tim Guan-tin Chien and contributors.\n * Released under the MIT license\n */\n\n'use strict'\n\n// setImmediate\nif (!window.setImmediate) {\n  window.setImmediate = (function setupSetImmediate () {\n    return window.msSetImmediate ||\n    window.webkitSetImmediate ||\n    window.mozSetImmediate ||\n    window.oSetImmediate ||\n    (function setupSetZeroTimeout () {\n      if (!window.postMessage || !window.addEventListener) {\n        return null\n      }\n\n      var callbacks = [undefined]\n      var message = 'zero-timeout-message'\n\n      // Like setTimeout, but only takes a function argument.  There's\n      // no time argument (always zero) and no arguments (you have to\n      // use a closure).\n      var setZeroTimeout = function setZeroTimeout (callback) {\n        var id = callbacks.length\n        callbacks.push(callback)\n        window.postMessage(message + id.toString(36), '*')\n\n        return id\n      }\n\n      window.addEventListener('message', function setZeroTimeoutMessage (evt) {\n        // Skipping checking event source, retarded IE confused this window\n        // object with another in the presence of iframe\n        if (typeof evt.data !== 'string' ||\n            evt.data.substr(0, message.length) !== message/* ||\n            evt.source !== window */) {\n          return\n        }\n\n        evt.stopImmediatePropagation()\n\n        var id = parseInt(evt.data.substr(message.length), 36)\n        if (!callbacks[id]) {\n          return\n        }\n\n        callbacks[id]()\n        callbacks[id] = undefined\n      }, true)\n\n      /* specify clearImmediate() here since we need the scope */\n      window.clearImmediate = function clearZeroTimeout (id) {\n        if (!callbacks[id]) {\n          return\n        }\n\n        callbacks[id] = undefined\n      }\n\n      return setZeroTimeout\n    })() ||\n    // fallback\n    function setImmediateFallback (fn) {\n      window.setTimeout(fn, 0)\n    }\n  })()\n}\n\nif (!window.clearImmediate) {\n  window.clearImmediate = (function setupClearImmediate () {\n    return window.msClearImmediate ||\n    window.webkitClearImmediate ||\n    window.mozClearImmediate ||\n    window.oClearImmediate ||\n    // \"clearZeroTimeout\" is implement on the previous block ||\n    // fallback\n    function clearImmediateFallback (timer) {\n      window.clearTimeout(timer)\n    }\n  })()\n}\n\n(function (global) {\n  // Check if WordCloud can run on this browser\n  var isSupported = (function isSupported () {\n    var canvas = document.createElement('canvas')\n    if (!canvas || !canvas.getContext) {\n      return false\n    }\n\n    var ctx = canvas.getContext('2d')\n    if (!ctx) {\n      return false\n    }\n    if (!ctx.getImageData) {\n      return false\n    }\n    if (!ctx.fillText) {\n      return false\n    }\n\n    if (!Array.prototype.some) {\n      return false\n    }\n    if (!Array.prototype.push) {\n      return false\n    }\n\n    return true\n  }())\n\n  // Find out if the browser impose minium font size by\n  // drawing small texts on a canvas and measure it's width.\n  var minFontSize = (function getMinFontSize () {\n    if (!isSupported) {\n      return\n    }\n\n    var ctx = document.createElement('canvas').getContext('2d')\n\n    // start from 20\n    var size = 20\n\n    // two sizes to measure\n    var hanWidth, mWidth\n\n    while (size) {\n      ctx.font = size.toString(10) + 'px sans-serif'\n      if ((ctx.measureText('\\uFF37').width === hanWidth) &&\n          (ctx.measureText('m').width) === mWidth) {\n        return (size + 1)\n      }\n\n      hanWidth = ctx.measureText('\\uFF37').width\n      mWidth = ctx.measureText('m').width\n\n      size--\n    }\n\n    return 0\n  })()\n\n  var getItemExtraData = function (item) {\n    if (Array.isArray(item)) {\n      var itemCopy = item.slice()\n      // remove data we already have (word and weight)\n      itemCopy.splice(0, 2)\n      return itemCopy\n    } else {\n      return []\n    }\n  }\n\n  // Based on http://jsfromhell.com/array/shuffle\n  var shuffleArray = function shuffleArray (arr) {\n    for (var j, x, i = arr.length; i;) {\n      j = Math.floor(Math.random() * i)\n      x = arr[--i]\n      arr[i] = arr[j]\n      arr[j] = x\n    }\n    return arr\n  }\n\n  var timer = {};\n  var WordCloud = function WordCloud (elements, options) {\n    if (!isSupported) {\n      return\n    }\n\n    var timerId = Math.floor(Math.random() * Date.now())\n\n    if (!Array.isArray(elements)) {\n      elements = [elements]\n    }\n\n    elements.forEach(function (el, i) {\n      if (typeof el === 'string') {\n        elements[i] = document.getElementById(el)\n        if (!elements[i]) {\n          throw new Error('The element id specified is not found.')\n        }\n      } else if (!el.tagName && !el.appendChild) {\n        throw new Error('You must pass valid HTML elements, or ID of the element.')\n      }\n    })\n\n    /* Default values to be overwritten by options object */\n    var settings = {\n      list: [],\n      fontFamily: '\"Trebuchet MS\", \"Heiti TC\", \"\u5FAE\u8EDF\u6B63\u9ED1\u9AD4\", ' +\n                  '\"Arial Unicode MS\", \"Droid Fallback Sans\", sans-serif',\n      fontWeight: 'normal',\n      color: 'random-dark',\n      minSize: 0, // 0 to disable\n      weightFactor: 1,\n      clearCanvas: true,\n      backgroundColor: '#fff', // opaque white = rgba(255, 255, 255, 1)\n\n      gridSize: 8,\n      drawOutOfBound: false,\n      shrinkToFit: false,\n      origin: null,\n\n      drawMask: false,\n      maskColor: 'rgba(255,0,0,0.3)',\n      maskGapWidth: 0.3,\n\n      wait: 0,\n      abortThreshold: 0, // disabled\n      abort: function noop () {},\n\n      minRotation: -Math.PI / 2,\n      maxRotation: Math.PI / 2,\n      rotationSteps: 0,\n\n      shuffle: true,\n      rotateRatio: 0.1,\n\n      shape: 'circle',\n      ellipticity: 0.65,\n\n      classes: null,\n\n      hover: null,\n      click: null\n    }\n\n    if (options) {\n      for (var key in options) {\n        if (key in settings) {\n          settings[key] = options[key]\n        }\n      }\n    }\n\n    /* Convert weightFactor into a function */\n    if (typeof settings.weightFactor !== 'function') {\n      var factor = settings.weightFactor\n      settings.weightFactor = function weightFactor (pt) {\n        return pt * factor // in px\n      }\n    }\n\n    /* Convert shape into a function */\n    if (typeof settings.shape !== 'function') {\n      switch (settings.shape) {\n        case 'circle':\n        /* falls through */\n        default:\n          // 'circle' is the default and a shortcut in the code loop.\n          settings.shape = 'circle'\n          break\n\n        case 'cardioid':\n          settings.shape = function shapeCardioid (theta) {\n            return 1 - Math.sin(theta)\n          }\n          break\n\n          /*\n          To work out an X-gon, one has to calculate \"m\",\n          where 1/(cos(2*PI/X)+m*sin(2*PI/X)) = 1/(cos(0)+m*sin(0))\n          http://www.wolframalpha.com/input/?i=1%2F%28cos%282*PI%2FX%29%2Bm*sin%28\n          2*PI%2FX%29%29+%3D+1%2F%28cos%280%29%2Bm*sin%280%29%29\n          Copy the solution into polar equation r = 1/(cos(t') + m*sin(t'))\n          where t' equals to mod(t, 2PI/X)\n         */\n\n        case 'diamond':\n          // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+\n          // %28t%2C+PI%2F2%29%29%2Bsin%28mod+%28t%2C+PI%2F2%29%29%29%2C+t+%3D\n          // +0+..+2*PI\n          settings.shape = function shapeSquare (theta) {\n            var thetaPrime = theta % (2 * Math.PI / 4)\n            return 1 / (Math.cos(thetaPrime) + Math.sin(thetaPrime))\n          }\n          break\n\n        case 'square':\n          // http://www.wolframalpha.com/input/?i=plot+r+%3D+min(1%2Fabs(cos(t\n          // )),1%2Fabs(sin(t)))),+t+%3D+0+..+2*PI\n          settings.shape = function shapeSquare (theta) {\n            return Math.min(\n              1 / Math.abs(Math.cos(theta)),\n              1 / Math.abs(Math.sin(theta))\n            )\n          }\n          break\n\n        case 'triangle-forward':\n          // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+\n          // %28t%2C+2*PI%2F3%29%29%2Bsqrt%283%29sin%28mod+%28t%2C+2*PI%2F3%29\n          // %29%29%2C+t+%3D+0+..+2*PI\n          settings.shape = function shapeTriangle (theta) {\n            var thetaPrime = theta % (2 * Math.PI / 3)\n            return 1 / (Math.cos(thetaPrime) +\n                        Math.sqrt(3) * Math.sin(thetaPrime))\n          }\n          break\n\n        case 'triangle':\n        case 'triangle-upright':\n          settings.shape = function shapeTriangle (theta) {\n            var thetaPrime = (theta + Math.PI * 3 / 2) % (2 * Math.PI / 3)\n            return 1 / (Math.cos(thetaPrime) +\n                        Math.sqrt(3) * Math.sin(thetaPrime))\n          }\n          break\n\n        case 'pentagon':\n          settings.shape = function shapePentagon (theta) {\n            var thetaPrime = (theta + 0.955) % (2 * Math.PI / 5)\n            return 1 / (Math.cos(thetaPrime) +\n                        0.726543 * Math.sin(thetaPrime))\n          }\n          break\n\n        case 'star':\n          settings.shape = function shapeStar (theta) {\n            var thetaPrime = (theta + 0.955) % (2 * Math.PI / 10)\n            if ((theta + 0.955) % (2 * Math.PI / 5) - (2 * Math.PI / 10) >= 0) {\n              return 1 / (Math.cos((2 * Math.PI / 10) - thetaPrime) +\n                          3.07768 * Math.sin((2 * Math.PI / 10) - thetaPrime))\n            } else {\n              return 1 / (Math.cos(thetaPrime) +\n                          3.07768 * Math.sin(thetaPrime))\n            }\n          }\n          break\n      }\n    }\n\n    /* Make sure gridSize is a whole number and is not smaller than 4px */\n    settings.gridSize = Math.max(Math.floor(settings.gridSize), 4)\n\n    /* shorthand */\n    var g = settings.gridSize\n    var maskRectWidth = g - settings.maskGapWidth\n\n    /* normalize rotation settings */\n    var rotationRange = Math.abs(settings.maxRotation - settings.minRotation)\n    var rotationSteps = Math.abs(Math.floor(settings.rotationSteps))\n    var minRotation = Math.min(settings.maxRotation, settings.minRotation)\n\n    /* information/object available to all functions, set when start() */\n    var grid, // 2d array containing filling information\n      ngx, ngy, // width and height of the grid\n      center, // position of the center of the cloud\n      maxRadius\n\n    /* timestamp for measuring each putWord() action */\n    var escapeTime\n\n    /* function for getting the color of the text */\n    var getTextColor\n    function randomHslColor (min, max) {\n      return 'hsl(' +\n        (Math.random() * 360).toFixed() + ',' +\n        (Math.random() * 30 + 70).toFixed() + '%,' +\n        (Math.random() * (max - min) + min).toFixed() + '%)'\n    }\n    switch (settings.color) {\n      case 'random-dark':\n        getTextColor = function getRandomDarkColor () {\n          return randomHslColor(10, 50)\n        }\n        break\n\n      case 'random-light':\n        getTextColor = function getRandomLightColor () {\n          return randomHslColor(50, 90)\n        }\n        break\n\n      default:\n        if (typeof settings.color === 'function') {\n          getTextColor = settings.color\n        }\n        break\n    }\n\n    /* function for getting the font-weight of the text */\n    var getTextFontWeight\n    if (typeof settings.fontWeight === 'function') {\n      getTextFontWeight = settings.fontWeight\n    }\n\n    /* function for getting the classes of the text */\n    var getTextClasses = null\n    if (typeof settings.classes === 'function') {\n      getTextClasses = settings.classes\n    }\n\n    /* Interactive */\n    var interactive = false\n    var infoGrid = []\n    var hovered\n\n    var getInfoGridFromMouseTouchEvent =\n    function getInfoGridFromMouseTouchEvent (evt) {\n      var canvas = evt.currentTarget\n      var rect = canvas.getBoundingClientRect()\n      var clientX\n      var clientY\n      /** Detect if touches are available */\n      if (evt.touches) {\n        clientX = evt.touches[0].clientX\n        clientY = evt.touches[0].clientY\n      } else {\n        clientX = evt.clientX\n        clientY = evt.clientY\n      }\n      var eventX = clientX - rect.left\n      var eventY = clientY - rect.top\n\n      var x = Math.floor(eventX * ((canvas.width / rect.width) || 1) / g)\n      var y = Math.floor(eventY * ((canvas.height / rect.height) || 1) / g)\n\n      return infoGrid[x][y]\n    }\n\n    var wordcloudhover = function wordcloudhover (evt) {\n      var info = getInfoGridFromMouseTouchEvent(evt)\n\n      if (hovered === info) {\n        return\n      }\n\n      hovered = info\n      if (!info) {\n        settings.hover(undefined, undefined, evt)\n\n        return\n      }\n\n      settings.hover(info.item, info.dimension, evt)\n    }\n\n    var wordcloudclick = function wordcloudclick (evt) {\n      var info = getInfoGridFromMouseTouchEvent(evt)\n      if (!info) {\n        return\n      }\n\n      settings.click(info.item, info.dimension, evt)\n      evt.preventDefault()\n    }\n\n    /* Get points on the grid for a given radius away from the center */\n    var pointsAtRadius = []\n    var getPointsAtRadius = function getPointsAtRadius (radius) {\n      if (pointsAtRadius[radius]) {\n        return pointsAtRadius[radius]\n      }\n\n      // Look for these number of points on each radius\n      var T = radius * 8\n\n      // Getting all the points at this radius\n      var t = T\n      var points = []\n\n      if (radius === 0) {\n        points.push([center[0], center[1], 0])\n      }\n\n      while (t--) {\n        // distort the radius to put the cloud in shape\n        var rx = 1\n        if (settings.shape !== 'circle') {\n          rx = settings.shape(t / T * 2 * Math.PI) // 0 to 1\n        }\n\n        // Push [x, y, t] t is used solely for getTextColor()\n        points.push([\n          center[0] + radius * rx * Math.cos(-t / T * 2 * Math.PI),\n          center[1] + radius * rx * Math.sin(-t / T * 2 * Math.PI) *\n            settings.ellipticity,\n          t / T * 2 * Math.PI])\n      }\n\n      pointsAtRadius[radius] = points\n      return points\n    }\n\n    /* Return true if we had spent too much time */\n    var exceedTime = function exceedTime () {\n      return ((settings.abortThreshold > 0) &&\n        ((new Date()).getTime() - escapeTime > settings.abortThreshold))\n    }\n\n    /* Get the deg of rotation according to settings, and luck. */\n    var getRotateDeg = function getRotateDeg () {\n      if (settings.rotateRatio === 0) {\n        return 0\n      }\n\n      if (Math.random() > settings.rotateRatio) {\n        return 0\n      }\n\n      if (rotationRange === 0) {\n        return minRotation\n      }\n\n      if (rotationSteps > 0) {\n        // Min rotation + zero or more steps * span of one step\n        return minRotation +\n          Math.floor(Math.random() * rotationSteps) *\n          rotationRange / (rotationSteps - 1)\n      } else {\n        return minRotation + Math.random() * rotationRange\n      }\n    }\n\n    var getTextInfo = function getTextInfo (word, weight, rotateDeg, extraDataArray) {\n      // calculate the acutal font size\n      // fontSize === 0 means weightFactor function wants the text skipped,\n      // and size < minSize means we cannot draw the text.\n      var debug = false\n      var fontSize = settings.weightFactor(weight)\n      if (fontSize <= settings.minSize) {\n        return false\n      }\n\n      // Scale factor here is to make sure fillText is not limited by\n      // the minium font size set by browser.\n      // It will always be 1 or 2n.\n      var mu = 1\n      if (fontSize < minFontSize) {\n        mu = (function calculateScaleFactor () {\n          var mu = 2\n          while (mu * fontSize < minFontSize) {\n            mu += 2\n          }\n          return mu\n        })()\n      }\n\n      // Get fontWeight that will be used to set fctx.font\n      var fontWeight\n      if (getTextFontWeight) {\n        fontWeight = getTextFontWeight(word, weight, fontSize, extraDataArray)\n      } else {\n        fontWeight = settings.fontWeight\n      }\n\n      var fcanvas = document.createElement('canvas')\n      var fctx = fcanvas.getContext('2d', { willReadFrequently: true })\n\n      fctx.font = fontWeight + ' ' +\n        (fontSize * mu).toString(10) + 'px ' + settings.fontFamily\n\n      // Estimate the dimension of the text with measureText().\n      var fw = fctx.measureText(word).width / mu\n      var fh = Math.max(fontSize * mu,\n        fctx.measureText('m').width,\n        fctx.measureText('\\uFF37').width\n      ) / mu\n\n      // Create a boundary box that is larger than our estimates,\n      // so text don't get cut of (it sill might)\n      var boxWidth = fw + fh * 2\n      var boxHeight = fh * 3\n      var fgw = Math.ceil(boxWidth / g)\n      var fgh = Math.ceil(boxHeight / g)\n      boxWidth = fgw * g\n      boxHeight = fgh * g\n\n      // Calculate the proper offsets to make the text centered at\n      // the preferred position.\n\n      // This is simply half of the width.\n      var fillTextOffsetX = -fw / 2\n      // Instead of moving the box to the exact middle of the preferred\n      // position, for Y-offset we move 0.4 instead, so Latin alphabets look\n      // vertical centered.\n      var fillTextOffsetY = -fh * 0.4\n\n      // Calculate the actual dimension of the canvas, considering the rotation.\n      var cgh = Math.ceil((boxWidth * Math.abs(Math.sin(rotateDeg)) +\n                           boxHeight * Math.abs(Math.cos(rotateDeg))) / g)\n      var cgw = Math.ceil((boxWidth * Math.abs(Math.cos(rotateDeg)) +\n                           boxHeight * Math.abs(Math.sin(rotateDeg))) / g)\n      var width = cgw * g\n      var height = cgh * g\n\n      fcanvas.setAttribute('width', width)\n      fcanvas.setAttribute('height', height)\n\n      if (debug) {\n        // Attach fcanvas to the DOM\n        document.body.appendChild(fcanvas)\n        // Save it's state so that we could restore and draw the grid correctly.\n        fctx.save()\n      }\n\n      // Scale the canvas with |mu|.\n      fctx.scale(1 / mu, 1 / mu)\n      fctx.translate(width * mu / 2, height * mu / 2)\n      fctx.rotate(-rotateDeg)\n\n      // Once the width/height is set, ctx info will be reset.\n      // Set it again here.\n      fctx.font = fontWeight + ' ' +\n        (fontSize * mu).toString(10) + 'px ' + settings.fontFamily\n\n      // Fill the text into the fcanvas.\n      // XXX: We cannot because textBaseline = 'top' here because\n      // Firefox and Chrome uses different default line-height for canvas.\n      // Please read https://bugzil.la/737852#c6.\n      // Here, we use textBaseline = 'middle' and draw the text at exactly\n      // 0.5 * fontSize lower.\n      fctx.fillStyle = '#000'\n      fctx.textBaseline = 'middle'\n      fctx.fillText(\n        word, fillTextOffsetX * mu,\n        (fillTextOffsetY + fontSize * 0.5) * mu\n      )\n\n      // Get the pixels of the text\n      var imageData = fctx.getImageData(0, 0, width, height).data\n\n      if (exceedTime()) {\n        return false\n      }\n\n      if (debug) {\n        // Draw the box of the original estimation\n        fctx.strokeRect(\n          fillTextOffsetX * mu,\n          fillTextOffsetY, fw * mu, fh * mu\n        )\n        fctx.restore()\n      }\n\n      // Read the pixels and save the information to the occupied array\n      var occupied = []\n      var gx = cgw\n      var gy, x, y\n      var bounds = [cgh / 2, cgw / 2, cgh / 2, cgw / 2]\n      while (gx--) {\n        gy = cgh\n        while (gy--) {\n          y = g\n          /* eslint no-labels: [\"error\", { \"allowLoop\": true }] */\n          singleGridLoop: while (y--) {\n            x = g\n            while (x--) {\n              if (imageData[((gy * g + y) * width +\n                (gx * g + x)) * 4 + 3]) {\n                occupied.push([gx, gy])\n\n                if (gx < bounds[3]) {\n                  bounds[3] = gx\n                }\n                if (gx > bounds[1]) {\n                  bounds[1] = gx\n                }\n                if (gy < bounds[0]) {\n                  bounds[0] = gy\n                }\n                if (gy > bounds[2]) {\n                  bounds[2] = gy\n                }\n\n                if (debug) {\n                  fctx.fillStyle = 'rgba(255, 0, 0, 0.5)'\n                  fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5)\n                }\n                break singleGridLoop\n              }\n            }\n          }\n          if (debug) {\n            fctx.fillStyle = 'rgba(0, 0, 255, 0.5)'\n            fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5)\n          }\n        }\n      }\n\n      if (debug) {\n        fctx.fillStyle = 'rgba(0, 255, 0, 0.5)'\n        fctx.fillRect(\n          bounds[3] * g,\n          bounds[0] * g,\n          (bounds[1] - bounds[3] + 1) * g,\n          (bounds[2] - bounds[0] + 1) * g\n        )\n      }\n\n      // Return information needed to create the text on the real canvas\n      return {\n        mu: mu,\n        occupied: occupied,\n        bounds: bounds,\n        gw: cgw,\n        gh: cgh,\n        fillTextOffsetX: fillTextOffsetX,\n        fillTextOffsetY: fillTextOffsetY,\n        fillTextWidth: fw,\n        fillTextHeight: fh,\n        fontSize: fontSize\n      }\n    }\n\n    /* Determine if there is room available in the given dimension */\n    var canFitText = function canFitText (gx, gy, gw, gh, occupied) {\n      // Go through the occupied points,\n      // return false if the space is not available.\n      var i = occupied.length\n      while (i--) {\n        var px = gx + occupied[i][0]\n        var py = gy + occupied[i][1]\n\n        if (px >= ngx || py >= ngy || px < 0 || py < 0) {\n          if (!settings.drawOutOfBound) {\n            return false\n          }\n          continue\n        }\n\n        if (!grid[px][py]) {\n          return false\n        }\n      }\n      return true\n    }\n\n    /* Actually draw the text on the grid */\n    var drawText = function drawText (gx, gy, info, word, weight, distance, theta, rotateDeg, attributes, extraDataArray) {\n      var fontSize = info.fontSize\n      var color\n      if (getTextColor) {\n        color = getTextColor(word, weight, fontSize, distance, theta, extraDataArray)\n      } else {\n        color = settings.color\n      }\n\n      // get fontWeight that will be used to set ctx.font and font style rule\n      var fontWeight\n      if (getTextFontWeight) {\n        fontWeight = getTextFontWeight(word, weight, fontSize, extraDataArray)\n      } else {\n        fontWeight = settings.fontWeight\n      }\n\n      var classes\n      if (getTextClasses) {\n        classes = getTextClasses(word, weight, fontSize, extraDataArray)\n      } else {\n        classes = settings.classes\n      }\n\n      elements.forEach(function (el) {\n        if (el.getContext) {\n          var ctx = el.getContext('2d')\n          var mu = info.mu\n\n          // Save the current state before messing it\n          ctx.save()\n          ctx.scale(1 / mu, 1 / mu)\n\n          ctx.font = fontWeight + ' ' +\n                     (fontSize * mu).toString(10) + 'px ' + settings.fontFamily\n          ctx.fillStyle = color\n\n          // Translate the canvas position to the origin coordinate of where\n          // the text should be put.\n          ctx.translate(\n            (gx + info.gw / 2) * g * mu,\n            (gy + info.gh / 2) * g * mu\n          )\n\n          if (rotateDeg !== 0) {\n            ctx.rotate(-rotateDeg)\n          }\n\n          // Finally, fill the text.\n\n          // XXX: We cannot because textBaseline = 'top' here because\n          // Firefox and Chrome uses different default line-height for canvas.\n          // Please read https://bugzil.la/737852#c6.\n          // Here, we use textBaseline = 'middle' and draw the text at exactly\n          // 0.5 * fontSize lower.\n          ctx.textBaseline = 'middle'\n          ctx.fillText(\n            word, info.fillTextOffsetX * mu,\n            (info.fillTextOffsetY + fontSize * 0.5) * mu\n          )\n\n          // The below box is always matches how <span>s are positioned\n          /* ctx.strokeRect(info.fillTextOffsetX, info.fillTextOffsetY,\n            info.fillTextWidth, info.fillTextHeight) */\n\n          // Restore the state.\n          ctx.restore()\n        } else {\n          // drawText on DIV element\n          var span = document.createElement('span')\n          var transformRule = ''\n          transformRule = 'rotate(' + (-rotateDeg / Math.PI * 180) + 'deg) '\n          if (info.mu !== 1) {\n            transformRule +=\n              'translateX(-' + (info.fillTextWidth / 4) + 'px) ' +\n              'scale(' + (1 / info.mu) + ')'\n          }\n          var styleRules = {\n            position: 'absolute',\n            display: 'block',\n            font: fontWeight + ' ' +\n              (fontSize * info.mu) + 'px ' + settings.fontFamily,\n            left: ((gx + info.gw / 2) * g + info.fillTextOffsetX) + 'px',\n            top: ((gy + info.gh / 2) * g + info.fillTextOffsetY) + 'px',\n            width: info.fillTextWidth + 'px',\n            height: info.fillTextHeight + 'px',\n            lineHeight: fontSize + 'px',\n            whiteSpace: 'nowrap',\n            transform: transformRule,\n            webkitTransform: transformRule,\n            msTransform: transformRule,\n            transformOrigin: '50% 40%',\n            webkitTransformOrigin: '50% 40%',\n            msTransformOrigin: '50% 40%'\n          }\n          if (color) {\n            styleRules.color = color\n          }\n          span.textContent = word\n          for (var cssProp in styleRules) {\n            span.style[cssProp] = styleRules[cssProp]\n          }\n          if (attributes) {\n            for (var attribute in attributes) {\n              span.setAttribute(attribute, attributes[attribute])\n            }\n          }\n          if (classes) {\n            span.className += classes\n          }\n          el.appendChild(span)\n        }\n      })\n    }\n\n    /* Help function to updateGrid */\n    var fillGridAt = function fillGridAt (x, y, drawMask, dimension, item) {\n      if (x >= ngx || y >= ngy || x < 0 || y < 0) {\n        return\n      }\n\n      grid[x][y] = false\n\n      if (drawMask) {\n        var ctx = elements[0].getContext('2d')\n        ctx.fillRect(x * g, y * g, maskRectWidth, maskRectWidth)\n      }\n\n      if (interactive) {\n        infoGrid[x][y] = { item: item, dimension: dimension }\n      }\n    }\n\n    /* Update the filling information of the given space with occupied points.\n       Draw the mask on the canvas if necessary. */\n    var updateGrid = function updateGrid (gx, gy, gw, gh, info, item) {\n      var occupied = info.occupied\n      var drawMask = settings.drawMask\n      var ctx\n      if (drawMask) {\n        ctx = elements[0].getContext('2d')\n        ctx.save()\n        ctx.fillStyle = settings.maskColor\n      }\n\n      var dimension\n      if (interactive) {\n        var bounds = info.bounds\n        dimension = {\n          x: (gx + bounds[3]) * g,\n          y: (gy + bounds[0]) * g,\n          w: (bounds[1] - bounds[3] + 1) * g,\n          h: (bounds[2] - bounds[0] + 1) * g\n        }\n      }\n\n      var i = occupied.length\n      while (i--) {\n        var px = gx + occupied[i][0]\n        var py = gy + occupied[i][1]\n\n        if (px >= ngx || py >= ngy || px < 0 || py < 0) {\n          continue\n        }\n\n        fillGridAt(px, py, drawMask, dimension, item)\n      }\n\n      if (drawMask) {\n        ctx.restore()\n      }\n    }\n\n    /* putWord() processes each item on the list,\n       calculate it's size and determine it's position, and actually\n       put it on the canvas. */\n    var putWord = function putWord (item) {\n      var word, weight, attributes\n      if (Array.isArray(item)) {\n        word = item[0]\n        weight = item[1]\n      } else {\n        word = item.word\n        weight = item.weight\n        attributes = item.attributes\n      }\n      var rotateDeg = getRotateDeg()\n\n      var extraDataArray = getItemExtraData(item)\n\n      // get info needed to put the text onto the canvas\n      var info = getTextInfo(word, weight, rotateDeg, extraDataArray)\n\n      // not getting the info means we shouldn't be drawing this one.\n      if (!info) {\n        return false\n      }\n\n      if (exceedTime()) {\n        return false\n      }\n\n      // If drawOutOfBound is set to false,\n      // skip the loop if we have already know the bounding box of\n      // word is larger than the canvas.\n      if (!settings.drawOutOfBound && !settings.shrinkToFit) {\n        var bounds = info.bounds;\n        if ((bounds[1] - bounds[3] + 1) > ngx ||\n          (bounds[2] - bounds[0] + 1) > ngy) {\n          return false\n        }\n      }\n\n      // Determine the position to put the text by\n      // start looking for the nearest points\n      var r = maxRadius + 1\n\n      var tryToPutWordAtPoint = function (gxy) {\n        var gx = Math.floor(gxy[0] - info.gw / 2)\n        var gy = Math.floor(gxy[1] - info.gh / 2)\n        var gw = info.gw\n        var gh = info.gh\n\n        // If we cannot fit the text at this position, return false\n        // and go to the next position.\n        if (!canFitText(gx, gy, gw, gh, info.occupied)) {\n          return false\n        }\n\n        // Actually put the text on the canvas\n        drawText(gx, gy, info, word, weight,\n          (maxRadius - r), gxy[2], rotateDeg, attributes, extraDataArray)\n\n        // Mark the spaces on the grid as filled\n        updateGrid(gx, gy, gw, gh, info, item)\n\n        // Return true so some() will stop and also return true.\n        return true\n      }\n\n      while (r--) {\n        var points = getPointsAtRadius(maxRadius - r)\n\n        if (settings.shuffle) {\n          points = [].concat(points)\n          shuffleArray(points)\n        }\n\n        // Try to fit the words by looking at each point.\n        // array.some() will stop and return true\n        // when putWordAtPoint() returns true.\n        // If all the points returns false, array.some() returns false.\n        var drawn = points.some(tryToPutWordAtPoint)\n\n        if (drawn) {\n          // leave putWord() and return true\n          return true\n        }\n      }\n      if (settings.shrinkToFit) {\n        if (Array.isArray(item)) {\n          item[1] = item[1] * 3 / 4\n        } else {\n          item.weight = item.weight * 3 / 4\n        }\n        return putWord(item)\n      }\n      // we tried all distances but text won't fit, return false\n      return false\n    }\n\n    /* Send DOM event to all elements. Will stop sending event and return\n       if the previous one is canceled (for cancelable events). */\n    var sendEvent = function sendEvent (type, cancelable, details) {\n      if (cancelable) {\n        return !elements.some(function (el) {\n          var event = new CustomEvent(type, {\n            detail: details || {}\n          })\n          return !el.dispatchEvent(event)\n        }, this)\n      } else {\n        elements.forEach(function (el) {\n          var event = new CustomEvent(type, {\n            detail: details || {}\n          })\n          el.dispatchEvent(event)\n        }, this)\n      }\n    }\n\n    /* Start drawing on a canvas */\n    var start = function start () {\n      // For dimensions, clearCanvas etc.,\n      // we only care about the first element.\n      var canvas = elements[0]\n\n      if (canvas.getContext) {\n        ngx = Math.ceil(canvas.width / g)\n        ngy = Math.ceil(canvas.height / g)\n      } else {\n        var rect = canvas.getBoundingClientRect()\n        ngx = Math.ceil(rect.width / g)\n        ngy = Math.ceil(rect.height / g)\n      }\n\n      // Sending a wordcloudstart event which cause the previous loop to stop.\n      // Do nothing if the event is canceled.\n      if (!sendEvent('wordcloudstart', true)) {\n        return\n      }\n\n      // Determine the center of the word cloud\n      center = (settings.origin)\n        ? [settings.origin[0] / g, settings.origin[1] / g]\n        : [ngx / 2, ngy / 2]\n\n      // Maxium radius to look for space\n      maxRadius = Math.floor(Math.sqrt(ngx * ngx + ngy * ngy))\n\n      /* Clear the canvas only if the clearCanvas is set,\n         if not, update the grid to the current canvas state */\n      grid = []\n\n      var gx, gy, i\n      if (!canvas.getContext || settings.clearCanvas) {\n        elements.forEach(function (el) {\n          if (el.getContext) {\n            var ctx = el.getContext('2d')\n            ctx.fillStyle = settings.backgroundColor\n            ctx.clearRect(0, 0, ngx * (g + 1), ngy * (g + 1))\n            ctx.fillRect(0, 0, ngx * (g + 1), ngy * (g + 1))\n          } else {\n            el.textContent = ''\n            el.style.backgroundColor = settings.backgroundColor\n            el.style.position = 'relative'\n          }\n        })\n\n        /* fill the grid with empty state */\n        gx = ngx\n        while (gx--) {\n          grid[gx] = []\n          gy = ngy\n          while (gy--) {\n            grid[gx][gy] = true\n          }\n        }\n      } else {\n        /* Determine bgPixel by creating\n           another canvas and fill the specified background color. */\n        var bctx = document.createElement('canvas').getContext('2d')\n\n        bctx.fillStyle = settings.backgroundColor\n        bctx.fillRect(0, 0, 1, 1)\n        var bgPixel = bctx.getImageData(0, 0, 1, 1).data\n\n        /* Read back the pixels of the canvas we got to tell which part of the\n           canvas is empty.\n           (no clearCanvas only works with a canvas, not divs) */\n        var imageData =\n          canvas.getContext('2d').getImageData(0, 0, ngx * g, ngy * g).data\n\n        gx = ngx\n        var x, y\n        while (gx--) {\n          grid[gx] = []\n          gy = ngy\n          while (gy--) {\n            y = g\n            /* eslint no-labels: [\"error\", { \"allowLoop\": true }] */\n            singleGridLoop: while (y--) {\n              x = g\n              while (x--) {\n                i = 4\n                while (i--) {\n                  if (imageData[((gy * g + y) * ngx * g +\n                                 (gx * g + x)) * 4 + i] !== bgPixel[i]) {\n                    grid[gx][gy] = false\n                    break singleGridLoop\n                  }\n                }\n              }\n            }\n            if (grid[gx][gy] !== false) {\n              grid[gx][gy] = true\n            }\n          }\n        }\n\n        imageData = bctx = bgPixel = undefined\n      }\n\n      // fill the infoGrid with empty state if we need it\n      if (settings.hover || settings.click) {\n        interactive = true\n\n        /* fill the grid with empty state */\n        gx = ngx + 1\n        while (gx--) {\n          infoGrid[gx] = []\n        }\n\n        if (settings.hover) {\n          canvas.addEventListener('mousemove', wordcloudhover)\n        }\n\n        if (settings.click) {\n          canvas.addEventListener('click', wordcloudclick)\n          canvas.style.webkitTapHighlightColor = 'rgba(0, 0, 0, 0)'\n        }\n\n        canvas.addEventListener('wordcloudstart', function stopInteraction () {\n          canvas.removeEventListener('wordcloudstart', stopInteraction)\n          canvas.removeEventListener('mousemove', wordcloudhover)\n          canvas.removeEventListener('click', wordcloudclick)\n          hovered = undefined\n        })\n      }\n\n      i = 0\n      var loopingFunction, stoppingFunction\n      if (settings.wait !== 0) {\n        loopingFunction = window.setTimeout\n        stoppingFunction = window.clearTimeout\n      } else {\n        loopingFunction = window.setImmediate\n        stoppingFunction = window.clearImmediate\n      }\n\n      var addEventListener = function addEventListener (type, listener) {\n        elements.forEach(function (el) {\n          el.addEventListener(type, listener)\n        }, this)\n      }\n\n      var removeEventListener = function removeEventListener (type, listener) {\n        elements.forEach(function (el) {\n          el.removeEventListener(type, listener)\n        }, this)\n      }\n\n      var anotherWordCloudStart = function anotherWordCloudStart () {\n        removeEventListener('wordcloudstart', anotherWordCloudStart)\n        stoppingFunction(timer[timerId])\n      }\n\n      addEventListener('wordcloudstart', anotherWordCloudStart)\n      timer[timerId] = loopingFunction(function loop () {\n        if (i >= settings.list.length) {\n          stoppingFunction(timer[timerId])\n          sendEvent('wordcloudstop', false)\n          removeEventListener('wordcloudstart', anotherWordCloudStart)\n          delete timer[timerId];\n          return\n        }\n        escapeTime = (new Date()).getTime()\n        var drawn = putWord(settings.list[i])\n        var canceled = !sendEvent('wordclouddrawn', true, {\n          item: settings.list[i],\n          drawn: drawn\n        })\n        if (exceedTime() || canceled) {\n          stoppingFunction(timer[timerId])\n          settings.abort()\n          sendEvent('wordcloudabort', false)\n          sendEvent('wordcloudstop', false)\n          removeEventListener('wordcloudstart', anotherWordCloudStart)\n          delete timer[timerId]\n          return\n        }\n        i++\n        timer[timerId] = loopingFunction(loop, settings.wait)\n      }, settings.wait)\n    }\n\n    // All set, start the drawing\n    start()\n  }\n\n  WordCloud.isSupported = isSupported\n  WordCloud.minFontSize = minFontSize\n  WordCloud.stop = function stop () {\n    if (timer) {\n      for (var timerId in timer) {\n        window.clearImmediate(timer[timerId])\n      }\n    }\n  }\n\n  // Expose the library as an AMD module\n  if (typeof define === 'function' && define.amd) { // eslint-disable-line no-undef\n    global.WordCloud = WordCloud\n    define('wordcloud', [], function () { return WordCloud }) // eslint-disable-line no-undef\n  } else if (typeof module !== 'undefined' && module.exports) { // eslint-disable-line no-undef\n    module.exports = WordCloud // eslint-disable-line no-undef\n  } else {\n    global.WordCloud = WordCloud\n  }\n})(this) // jshint ignore:line\n", "export default require(\"./node_modules/wordcloud/src/wordcloud2.js\");"],
  "mappings": "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",
  "names": []
}
